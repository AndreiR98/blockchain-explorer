import {
  require_crypto
} from "./chunk-7AMTDEL5.js";
import {
  __commonJS
} from "./chunk-WNKWOKNR.js";

// node_modules/int/int.js
var require_int = __commonJS({
  "node_modules/int/int.js"(exports, module) {
    var Int = function(num) {
      if (!(this instanceof Int)) {
        return new Int(num);
      }
      var self = this;
      if (num instanceof Int) {
        self._s = num._s;
        self._d = num._d.slice();
        return;
      }
      self._s = (num += "").charAt(0) === "-" ? 1 : 0;
      self._d = [];
      num = num.replace(/[^\d]/g, "");
      var ln = num.length;
      for (var i = 0; i < ln; ++i) {
        self._d.push(+num[i]);
      }
      trim_zeros(self);
      if (self._d.length === 0) {
        self._s = 0;
      }
    };
    Int.prototype.add = function(num) {
      var self = this;
      var num = ensure_int(num);
      if (self._s != num._s) {
        num._s ^= 1;
        var res = self.sub(num);
        num._s ^= 1;
        return res;
      }
      if (self._d.length < num._d.length) {
        var a = self._d;
        var b = num._d;
        var out = Int(num);
      } else {
        var a = num._d;
        var b = self._d;
        var out = Int(self);
      }
      var la = a.length;
      var lb = b.length;
      var res = out._d;
      var carry = 0;
      for (var i = lb - 1, j = la - 1; i >= 0, j >= 0; --i, --j) {
        res[i] += carry + a[j];
        carry = 0;
        if (res[i] >= 10) {
          res[i] -= 10;
          carry = 1;
        }
      }
      for (; i >= 0; --i) {
        res[i] += carry;
        carry = 0;
        if (res[i] >= 10) {
          res[i] -= 10;
          carry = 1;
        }
        if (carry === 0) {
          break;
        }
      }
      if (carry > 0) {
        res.unshift(1);
      }
      return out;
    };
    Int.prototype.sub = function(num) {
      var self = this;
      var num = Int(num);
      if (self._s != num._s) {
        num._s ^= 1;
        var res = this.add(num);
        num._s ^= 1;
        return res;
      }
      var s1 = self._s;
      var s2 = num._s;
      self._s = num._s = 0;
      var c = self.lt(num);
      var a = c ? self._d : num._d;
      var b = c ? num._d : self._d;
      self._s = s1;
      num._s = s2;
      var la = a.length;
      var lb = b.length;
      var out = Int(c ? num : self);
      out._s = num._s & self._s;
      var res = out._d;
      var borrow = 0;
      for (var i = lb - 1, j = la - 1; i >= 0, j >= 0; --i, --j) {
        res[i] -= a[j] + borrow;
        borrow = 0;
        if (res[i] < 0) {
          res[i] += 10;
          borrow = 1;
        }
      }
      for (; i >= 0; --i) {
        res[i] -= borrow;
        borrow = 0;
        if (res[i] < 0) {
          res[i] += 10;
          borrow = 1;
        }
        if (borrow === 0) {
          break;
        }
      }
      c && (out._s ^= 1);
      trim_zeros(out);
      if (out._d.length === 0) {
        out._s = 0;
      }
      return out;
    };
    Int.prototype.mul = function(num) {
      var self = this;
      var r = self._d.length >= (num = Int(num))._d.length;
      var a = (r ? self : num)._d;
      var b = (r ? num : self)._d;
      var la = a.length;
      var lb = b.length;
      var sum = Int();
      var zeros = [];
      for (var i = lb - 1; i >= 0; --i) {
        var out = Int();
        var val = out._d = out._d.concat(zeros);
        var carry = 0;
        for (var j = la - 1; j >= 0; --j) {
          var mul = b[i] * a[j] + carry;
          var res = mul % 10;
          carry = Math.floor(mul / 10);
          val.unshift(res);
        }
        if (carry) {
          val.unshift(carry);
        }
        sum = sum.add(out);
        zeros.push(0);
      }
      sum._s = self._s ^ num._s;
      return sum;
    };
    Int.prototype.div = function(num) {
      var self = this;
      var num = Int(num);
      if (num == "0") {
        throw new Error("Division by 0");
      } else if (self == "0") {
        return Int();
      }
      var numerator = self._d.slice();
      var quo = Int();
      quo._s = self._s ^ num._s;
      var orig_s = num._s;
      num._s = 0;
      var rem = Int();
      while (numerator.length) {
        var c = 0;
        while (numerator.length && rem.lt(num)) {
          if (c++ > 0) {
            quo._d.push(0);
          }
          rem._d.push(numerator.shift());
          trim_zeros(rem);
        }
        var count = 0;
        while (rem.gte(num) && ++count) {
          rem = rem.sub(num);
        }
        if (count === 0) {
          quo._d.push(0);
          break;
        }
        quo._d.push(count);
      }
      var rlen = rem._d.length;
      if (rlen > 1 || quo._s && rlen > 0) {
        rem = rem.add(5);
      }
      if (quo._s && (rlen !== rem._d.length || rem._d[0] >= 5)) {
        quo = quo.sub(1);
      }
      num._s = orig_s;
      return trim_zeros(quo);
    };
    Int.prototype.mod = function(num) {
      return this.sub(this.div(num).mul(num));
    };
    Int.prototype.pow = function(num) {
      var out = Int(this);
      if ((num = Int(num)) == 0) {
        return out.set(1);
      }
      for (var i = Math.abs(num); --i; out.set(out.mul(this)))
        ;
      return num < 0 ? out.set(Int(1).div(out)) : out;
    };
    Int.prototype.set = function(num) {
      this.constructor(num);
      return this;
    };
    Int.prototype.cmp = function(num) {
      var self = this;
      var num = ensure_int(num);
      if (self._s != num._s) {
        return self._s ? -1 : 1;
      }
      var a = self._d;
      var b = num._d;
      var la = a.length;
      var lb = b.length;
      if (la != lb) {
        return la > lb ^ self._s ? 1 : -1;
      }
      for (var i = 0; i < la; ++i) {
        if (a[i] != b[i]) {
          return a[i] > b[i] ^ self._s ? 1 : -1;
        }
      }
      return 0;
    };
    Int.prototype.neg = function() {
      var out = Int(this);
      out._s ^= 1;
      return out;
    };
    Int.prototype.abs = function() {
      var out = Int(this);
      out._s = 0;
      return out;
    };
    Int.prototype.valueOf = Int.prototype.toString = function(radix) {
      var self = this;
      if (!radix || radix === 10) {
        return (self._s && self._d.length ? "-" : "") + (self._d.length ? self._d.join("") : "0");
      }
      if (radix < 2 || radix > 36) {
        throw RangeError("radix out of range: " + radix);
      }
      var radix_pow = Math.pow(radix, 6);
      var rem = self;
      var result = "";
      while (true) {
        var div = rem.div(radix_pow);
        var int = rem.sub(div.mul(radix_pow));
        var digits = (+int.toString()).toString(radix);
        rem = div;
        if (rem.eq(0)) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Int.prototype.gt = function(num) {
      return this.cmp(num) > 0;
    };
    Int.prototype.gte = function(num) {
      return this.cmp(num) >= 0;
    };
    Int.prototype.eq = function(num) {
      return this.cmp(num) === 0;
    };
    Int.prototype.ne = function(num) {
      return this.cmp(num) !== 0;
    };
    Int.prototype.lt = function(num) {
      return this.cmp(num) < 0;
    };
    Int.prototype.lte = function(num) {
      return this.cmp(num) <= 0;
    };
    function ensure_int(val) {
      if (val instanceof Int) {
        return val;
      }
      return Int(val);
    }
    function trim_zeros(int) {
      while (int._d.length && int._d[0] === 0) {
        int._d.shift();
      }
      return int;
    }
    module.exports = Int;
  }
});

// node_modules/bitcoin-address/base58.js
var require_base58 = __commonJS({
  "node_modules/bitcoin-address/base58.js"(exports, module) {
    var int = require_int();
    var vals = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var positions = {};
    for (i = 0; i < vals.length; ++i) {
      positions[vals[i]] = i;
    }
    var i;
    function decode(payload) {
      var base = 58;
      var length = payload.length;
      var num = int(0);
      var leading_zero = 0;
      var seen_other = false;
      for (var i2 = 0; i2 < length; ++i2) {
        var char = payload[i2];
        var p = positions[char];
        if (p === void 0) {
          throw new Error("invalid base58 string: " + payload);
        }
        num = num.mul(base).add(p);
        if (char == "1" && !seen_other) {
          ++leading_zero;
        } else {
          seen_other = true;
        }
      }
      var hex = num.toString(16);
      if (hex.length % 2 !== 0) {
        hex = "0" + hex;
      }
      if (leading_zero && !seen_other) {
        --leading_zero;
      }
      while (leading_zero-- > 0) {
        hex = "00" + hex;
      }
      return hex;
    }
    module.exports.decode = decode;
  }
});

// node_modules/bitcoin-address/index.js
var require_bitcoin_address = __commonJS({
  "node_modules/bitcoin-address/index.js"(exports, module) {
    var crypto = require_crypto();
    var base58 = require_base58();
    var address_types = {
      prod: "00",
      testnet: "6f"
    };
    var p2sh_types = {
      prod: "05",
      testnet: "c4"
    };
    function get_address_type(address) {
      var decoded_hex;
      try {
        decoded_hex = base58.decode(address);
      } catch (e) {
        return null;
      }
      var decoded = new Buffer(decoded_hex, "hex");
      if (decoded.length != 25) {
        return null;
      }
      var length = decoded.length;
      var cksum = decoded.slice(length - 4, length).toString("binary");
      var body = decoded.slice(0, length - 4);
      var good_cksum = sha256_digest(sha256_digest(body)).toString("binary").substr(0, 4);
      return cksum === good_cksum ? decoded_hex.slice(0, 2) : null;
    }
    module.exports.get_address_type = get_address_type;
    function validate(address, address_type) {
      address_type = address_type || "prod";
      var type = get_address_type(address);
      if (type === null) {
        return false;
      }
      if (type !== address_types[address_type] && type !== p2sh_types[address_type]) {
        return false;
      }
      return true;
    }
    module.exports.validate = validate;
    function sha256_digest(payload) {
      return crypto.createHash("sha256").update(payload).digest();
    }
  }
});
export default require_bitcoin_address();
//# sourceMappingURL=bitcoin-address.js.map
