import {
  __commonJS
} from "./chunk-WNKWOKNR.js";

// node_modules/ecdsa-secp256k1/config.js
var require_config = __commonJS({
  "node_modules/ecdsa-secp256k1/config.js"(exports, module) {
    var config = {
      "secp256k1": {
        p: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2Fn,
        a: 0n,
        b: 7n,
        G: 0x0479BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8n,
        n: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n,
        h: 1n
      }
    };
    module.exports = config;
  }
});

// node_modules/ecdsa-secp256k1/lib.js
var require_lib = __commonJS({
  "node_modules/ecdsa-secp256k1/lib.js"(exports, module) {
    function num2Point(num) {
      let numHex = num.toString(16);
      let len = 129;
      if (numHex.length != len) {
        throw new Error(`point num length must be ${len}!`);
      }
      if (numHex[0] != "4") {
        throw new Error("point num data not right!");
      }
      let startX = 1;
      let startY = 65;
      let offset = 64;
      return { x: BigInt(`0x${numHex.slice(startX, startX + offset)}`), y: BigInt(`0x${numHex.slice(startY, startY + offset)}`) };
    }
    function point2HexStr(point) {
      return `0x04${point.x.toString(16)}${point.y.toString(16)}`;
    }
    function point2Num(point) {
      return BigInt(point2HexStr(point));
    }
    function postiveMod(num, modNum) {
      return (num % modNum + modNum) % modNum;
    }
    function inverseMulti(x, modNum) {
      let x1 = 1n, x2 = 0n, x3 = modNum;
      let y1 = 0n, y2 = 1n, y3 = (x % modNum + modNum) % modNum;
      let q;
      let t1, t2, t3;
      while (true) {
        if (y3 == 0n)
          throw new Error("multiplicative inverse modulo is no answer!");
        if (y3 == 1n)
          return y2;
        q = x3 / y3;
        t1 = x1 - q * y1;
        t2 = x2 - q * y2;
        t3 = x3 - q * y3;
        x1 = y1;
        x2 = y2;
        x3 = y3;
        y1 = t1;
        y2 = t2;
        y3 = t3;
      }
    }
    function getPrivteKeyNumByRand(n) {
      let nHex = n.toString(16);
      let privteKeyList = [];
      let isZero = true;
      for (let i = 0; i < nHex.length; i++) {
        let rand16Num = Math.round(Math.random() * parseInt(nHex[i], 16));
        privteKeyList.push(rand16Num.toString(16));
        if (rand16Num > 0) {
          isZero = false;
        }
      }
      if (isZero) {
        return getPrivteKeyNumByRand(n);
      }
      return BigInt(`0x${privteKeyList.join("")}`);
    }
    function addSamePoint(x1, y1, modNum, a) {
      let ru = postiveMod((3n * x1 ** 2n + a) * inverseMulti(2n * y1, modNum), modNum);
      let x3 = postiveMod(ru ** 2n - 2n * x1, modNum);
      let y3 = postiveMod(ru * (x1 - x3) - y1, modNum);
      return { x: x3, y: y3 };
    }
    function addDiffPoint(x1, y1, x2, y2, modNum) {
      let ru = postiveMod((y2 - y1) * inverseMulti(x2 - x1, modNum), modNum);
      let x3 = postiveMod(ru ** 2n - x1 - x2, modNum);
      let y3 = postiveMod(ru * (x1 - x3) - y1, modNum);
      return { x: x3, y: y3 };
    }
    function getPointByNum(num, pointG, p, a) {
      let numBin = num.toString(2);
      let nowPoint = null;
      let nextPoint = pointG;
      for (let i = numBin.length - 1; i >= 0; i--) {
        if (numBin[i] == "1") {
          if (nowPoint === null) {
            nowPoint = nextPoint;
          } else {
            nowPoint = addDiffPoint(nowPoint.x, nowPoint.y, nextPoint.x, nextPoint.y, p);
          }
        }
        nextPoint = addSamePoint(nextPoint.x, nextPoint.y, p, a);
      }
      return nowPoint;
    }
    function sign(n, pointG, p, a, d, mNum) {
      let k, R;
      let r = 0n;
      while (r == 0n) {
        k = getPrivteKeyNumByRand(n);
        R = getPointByNum(k, pointG, p, a);
        r = postiveMod(R.x, n);
      }
      let e = mNum;
      let s = postiveMod((e + r * d) * inverseMulti(k, n), n);
      if (s == 0n) {
        return sign(n, pointG, p, a, d, M, encoding);
      }
      return { r, s };
    }
    function verify(n, pointG, p, a, pointQ, S, mNum) {
      let { r, s } = S;
      if (!(r > 0n && r < n && s > 0n && s < n)) {
        return false;
      }
      let e = mNum;
      let w = inverseMulti(s, n);
      let u1 = postiveMod(e * w, n);
      let u2 = postiveMod(r * w, n);
      let u1Point = getPointByNum(u1, pointG, p, a);
      let u2Point = getPointByNum(u2, pointQ, p, a);
      let pointR;
      if (u1Point.x == u2Point.x && u1Point.y == u2Point.y) {
        pointR = addSamePoint(u1Point.x, u1Point.y, p, a);
      } else {
        pointR = addDiffPoint(u1Point.x, u1Point.y, u2Point.x, u2Point.y, p);
      }
      if (pointR.x == 0n && pointR.y == 0n) {
        return false;
      }
      let v = postiveMod(pointR.x, n);
      if (v == r) {
        return true;
      }
      return false;
    }
    module.exports = {
      num2Point,
      point2HexStr,
      point2Num,
      getPrivteKeyNumByRand,
      addSamePoint,
      addDiffPoint,
      getPointByNum,
      sign,
      verify
    };
  }
});

// node_modules/ecdsa-secp256k1/index.js
var require_ecdsa_secp256k1 = __commonJS({
  "node_modules/ecdsa-secp256k1/index.js"(exports, module) {
    var secp256k1Config = require_config()["secp256k1"];
    var ecc = require_lib();
    var pointG = ecc.num2Point(secp256k1Config.G);
    function StringConvertBigNum(num) {
      if (typeof num == "string") {
        return BigInt(num);
      }
      return num;
    }
    function randPrivateKeyNum() {
      return ecc.getPrivteKeyNumByRand(secp256k1Config.n);
    }
    function publicKeyNum2Point(publicKeyNum) {
      return ecc.num2Point(StringConvertBigNum(publicKeyNum));
    }
    function publicKeyPoint2HexStr(publicKeyPoint) {
      return ecc.point2HexStr({
        x: StringConvertBigNum(publicKeyPoint.x),
        y: StringConvertBigNum(publicKeyPoint.y)
      });
    }
    function publicKeyPoint2Num(publicKeyPoint) {
      return ecc.point2Num({
        x: StringConvertBigNum(publicKeyPoint.x),
        y: StringConvertBigNum(publicKeyPoint.y)
      });
    }
    function getPublicKeyPoint(privateKeyNum) {
      return ecc.getPointByNum(
        StringConvertBigNum(privateKeyNum),
        pointG,
        secp256k1Config.p,
        secp256k1Config.a
      );
    }
    function sign(privateKeyNum, msgDataNum) {
      return ecc.sign(
        secp256k1Config.n,
        pointG,
        secp256k1Config.p,
        secp256k1Config.a,
        StringConvertBigNum(privateKeyNum),
        StringConvertBigNum(msgDataNum)
      );
    }
    function verify(publicKeyPoint, signData, msgDataNum) {
      return ecc.verify(
        secp256k1Config.n,
        pointG,
        secp256k1Config.p,
        secp256k1Config.a,
        {
          x: StringConvertBigNum(publicKeyPoint.x),
          y: StringConvertBigNum(publicKeyPoint.y)
        },
        StringConvertBigNum(signData),
        StringConvertBigNum(msgDataNum)
      );
    }
    var defaultData = {
      publicKeyNum2Point,
      publicKeyPoint2HexStr,
      publicKeyPoint2Num,
      randPrivateKeyNum,
      getPublicKeyPoint,
      sign,
      verify
    };
    module.exports = defaultData;
    module.exports.default = defaultData;
  }
});
export default require_ecdsa_secp256k1();
//# sourceMappingURL=ecdsa-secp256k1.js.map
